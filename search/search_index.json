{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Physics Motion Tracking Lab","text":"<pre><code>MotionTrackerLab\n\u251c\u2500 scripts # contains all scripts for launching programs\n\u251c\u2500 motiontracker # main library for motion tracking\n\u251c\u2500 labweb # contains files for the webserver\n\u2502  \u251c\u2500 frontend # javascript code (React) for clients\n\u2502  \u2514\u2500 backend # python code for webserver\n\u251c\u2500 labconfig # python code for all configuration\n\u251c\u2500 logs # log text files will be saved here\n\u251c\u2500 data # any saved motion tracking data is saved here\n\u251c\u2500 tests # contains all test files \n\u2514\u2500 assets # pictures for documentation website\n</code></pre>"},{"location":"#notes","title":"Notes","text":"<p>I have made up my mind to just cleanly separate frontend from backend.</p> <p>What if someone navigates away from the camera after 10 seconds! Do I really want to turn off the camera! Or do a soft reset. What if they are just looking at graphs!</p>"},{"location":"#install","title":"Install","text":"<ol> <li><code>pip install -e .[dev]</code> - For Development</li> <li><code>npm install</code></li> </ol>"},{"location":"#production-run","title":"Production Run","text":"<p>This will run the webserver</p> <ol> <li><code>npm run build</code></li> <li><code>uvicorn labweb:app</code></li> </ol>"},{"location":"#development","title":"Development","text":"<p>These instruction are for developers working on the project.</p>"},{"location":"#development-mode","title":"Development Mode","text":"<p>Open two terminals</p> <ol> <li><code>uvicorn labweb:app</code></li> <li><code>npm run start</code></li> </ol> <p>Open the url: <code>http://127.0.0.1:8000</code></p>"},{"location":"#scripts","title":"Scripts","text":"<p>Demo</p> <ol> <li><code>python -m scripts.run_demo</code></li> </ol>"},{"location":"#tests","title":"Tests","text":"<p>To simply run the tests: <code>pytest -v</code></p> <p>To see all captured output (debugging): <code>pytest -rPx -v</code></p>"},{"location":"#notes_1","title":"Notes","text":"<p>https://ajhyndman.medium.com/hot-reloading-with-react-and-flask-b5dae60d9898</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd motiontrackerlab\npip install -e[dev]\n</code></pre>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git checkout -b feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Then create a pull request!</p>"},{"location":"license/","title":"License","text":"<pre><code>Copyright (c) 2022-2023 Jeremy Castagno and others\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"how-to-guides/software-advanced/","title":"Tracking Software - Advanced","text":"<p>Advanced tutorial here.</p>"},{"location":"reference/motiontracker/","title":"motiontracker","text":""},{"location":"reference/motiontracker/calibration/","title":"calibration","text":""},{"location":"reference/motiontracker/calibration/#motiontracker.calibration.coord_transform","title":"<code>coord_transform(obj_coord_pixels, cal_vec)</code>","text":"<p>Calculate x and y coordinates (in cm) based on the coefficients (c_1 - c_8) from     the fractional transformation and the pixel coordinates of each point     x = (c_1u + c_2v + c_3)/(1 + c_7u + c_8v)     y = (c_4u + c_5v + c_6)/(1 + c_7u + c_8v)</p> <p>Parameters:</p> Name Type Description Default <code>obj_coord_pixels</code> <code>tuple</code> <p>the (row, col) tuple of the pixel. Note that Y comes first</p> required <code>cal_vec</code> <code>list</code> <p>Parameters of DLT</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The [x,y] coordiate in local space. Note that X comes first!</p> Source code in <code>motiontracker\\calibration.py</code> <pre><code>def coord_transform(obj_coord_pixels, cal_vec):\n\"\"\"Calculate x and y coordinates (in cm) based on the coefficients (c_1 - c_8) from\n        the fractional transformation and the pixel coordinates of each point\n        x = (c_1*u + c_2*v + c_3)/(1 + c_7*u + c_8*v)\n        y = (c_4*u + c_5*v + c_6)/(1 + c_7*u + c_8*v)\n\n    Args:\n        obj_coord_pixels (tuple): the (row, col) tuple of the pixel. Note that Y comes first\n        cal_vec (list): Parameters of DLT\n\n    Returns:\n        list: The [x,y] coordiate in local space. Note that X comes first!\n    \"\"\"    \n\n    obj_x = (cal_vec[0]*obj_coord_pixels[1] + cal_vec[1]*obj_coord_pixels[0] + cal_vec[2])/\\\n    (1.0 + cal_vec[6]*obj_coord_pixels[1] + cal_vec[7]*obj_coord_pixels[0])\n\n    obj_y = (cal_vec[3]*obj_coord_pixels[1] + cal_vec[4]*obj_coord_pixels[0] + cal_vec[5])/\\\n    (1.0 + cal_vec[6]*obj_coord_pixels[1] + cal_vec[7]*obj_coord_pixels[0])\n\n    return [obj_x, obj_y]\n</code></pre>"},{"location":"reference/motiontracker/calibration/#motiontracker.calibration.get_hsl_lo_hi","title":"<code>get_hsl_lo_hi(hsv, px, py, **kwargs)</code>","text":"<p>Get the lo and hi hsl values that should threshold the pixel at (py,px)</p> Source code in <code>motiontracker\\calibration.py</code> <pre><code>def get_hsl_lo_hi(hsv:np.ndarray, px:int, py:int, **kwargs):\n\"\"\" Get the lo and hi hsl values that should threshold the pixel at (py,px)\"\"\"\n    binary_image = np.zeros(shape=(hsv.shape[0], hsv.shape[1]), dtype=np.uint8)\n    binary_image = region_growing(hsv, (py, px), binary_image, **kwargs)\n    binary_image = binary_image.astype(bool)\n    mean = hsv[binary_image, :].mean(axis=0)\n    std = hsv[binary_image, :].std(axis=0)\n    hsv_lo = np.clip(mean - 3 * std, a_min=[0, 0, 0], a_max=[180, 255, 255]).astype(int)\n    hsv_hi = np.clip(mean + 3 * std, a_min=[0, 0, 0], a_max=[180, 255, 255]).astype(int)\n    return hsv_lo, hsv_hi\n</code></pre>"},{"location":"reference/motiontracker/log/","title":"log","text":""},{"location":"reference/motiontracker/tracker/","title":"tracker","text":""},{"location":"reference/motiontracker/tracker/#motiontracker.tracker.Tracker","title":"<code>Tracker(camera, callback_thread_closed=None, callback_new_tracking_position=None)</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>motiontracker\\tracker.py</code> <pre><code>def __init__(\n    self,\n    camera: BaseCamera,\n    callback_thread_closed=None,\n    callback_new_tracking_position=None,\n):\n\"\"\"Start the background camera thread if it isn't running yet.\"\"\"\n    Tracker.camera = camera\n    Tracker.callback_thread_closed = callback_thread_closed\n    Tracker.callback_new_tracking_position = callback_new_tracking_position\n</code></pre>"},{"location":"reference/motiontracker/tracker/#motiontracker.tracker.Tracker.get_frame","title":"<code>get_frame(timeout=None)</code>","text":"<p>Return the current camera frame.</p> Source code in <code>motiontracker\\tracker.py</code> <pre><code>def get_frame(self, timeout=None):\n\"\"\"Return the current camera frame.\"\"\"\n    # if the camera is off just return the dummy image\n    if Tracker.thread is None or Tracker.stop_tracking_flag:\n        log.warn(\"Tracking thread has not started! Sending Dummy Image from camera\")\n        return Tracker.camera.get_frame()\n\n    log.debug(\"Inside Tracker Get Frame, Waiting for Event\")\n    success = Tracker.event.wait(timeout=timeout)\n    if not success:\n        log.debug(\"Tracker frame took too long, raising exception\")\n        raise RuntimeError(\"No tracking frame received\")\n    Tracker.event.clear()\n    return Tracker.track_frame\n</code></pre>"},{"location":"reference/motiontracker/trackerstate/","title":"trackerstate","text":""},{"location":"reference/motiontracker/trackerstate/#motiontracker.trackerstate.MotionTrackerController","title":"<code>MotionTrackerController(config)</code>","text":"<p>         Bases: <code>StateMachine</code></p> <p>State machine for webserver</p> Source code in <code>motiontracker\\trackerstate.py</code> <pre><code>def __init__(self, config: Config):\n    StateMachine.__init__(self)\n    self.config = config\n    camera_config = config[\"motion_tracker\"][\"camera\"]\n    if \"video_fpath\" in camera_config:\n        self.camera = CameraVideo(\n            **camera_config,\n            callback_thread_closed=self.callback_camera_thread_closed,\n        )\n    else:\n        self.camera = CameraCV(\n            **camera_config,\n            callback_thread_closed=self.callback_camera_thread_closed,\n        )\n    self.tracker = Tracker(\n        camera=self.camera,\n        callback_thread_closed=self.callback_tracking_thread_closed,\n    )\n\n    # all states that indicate the camera is on\n    self.camera_on_states = [\n        self.calibrating.id,\n        self.calibrated.id,\n        self.tracking.id,\n        self.experiment.id,\n        self.recording.id,\n    ]\n    # states where tracking is happening\n    self.tracking_on_states = [\n        self.tracking.id,\n        self.experiment.id,\n        self.recording.id,\n    ]\n\n    self.recording_main_directory = Path(CONFIG[\"motion_tracker\"][\"recording\"][\"save_directory\"])\n    if not self.recording_main_directory.exists():\n        log.info(f\"Creating {self.recording_main_directory}\")\n        self.recording_main_directory.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/motiontracker/trackerstate/#motiontracker.trackerstate.MotionTrackerController.on_enter_calibrated","title":"<code>on_enter_calibrated(event, state)</code>","text":"<p>This event should be called only after the calibration_points_pixels have been received and updated</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>_type_</code> <p>description</p> required <code>state</code> <code>_type_</code> <p>description</p> required Source code in <code>motiontracker\\trackerstate.py</code> <pre><code>def on_enter_calibrated(self, event, state):\n\"\"\"This event should be called only after the calibration_points_pixels have been received and updated\n\n    Args:\n        event (_type_): _description_\n        state (_type_): _description_\n    \"\"\"\n    self.dlt = find_transition_matrix(\n        self.calibration_coordinates_px,\n        CONFIG[\"motion_tracker\"][\"calibration_stickers\"][\"coordinates_local\"],\n    )\n    log.info(f\"Updating DLT matrix: {self.dlt}\")\n</code></pre>"},{"location":"reference/motiontracker/trackerstate/#motiontracker.trackerstate.MotionTrackerController.on_enter_tracking","title":"<code>on_enter_tracking(event, state, start=None)</code>","text":"<p>This event should be called only after the calibration_points_pixels have been received and updated</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>_type_</code> <p>description</p> required <code>state</code> <code>_type_</code> <p>description</p> required Source code in <code>motiontracker\\trackerstate.py</code> <pre><code>def on_enter_tracking(self, event, state, start: PointInt = None):\n\"\"\"This event should be called only after the calibration_points_pixels have been received and updated\n\n    Args:\n        event (_type_): _description_\n        state (_type_): _description_\n    \"\"\"\n    log.info(f\"Entering tracking state with start coordinates: {start}\")\n    self.tracker.start_tracking(start.x, start.y, self.dlt)\n</code></pre>"},{"location":"reference/motiontracker/camera/","title":"camera","text":""},{"location":"reference/motiontracker/camera/base_camera/","title":"base_camera","text":""},{"location":"reference/motiontracker/camera/base_camera/#motiontracker.camera.base_camera.BaseCamera","title":"<code>BaseCamera(width=640, height=360, callback_thread_closed=None)</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>motiontracker\\camera\\base_camera.py</code> <pre><code>def __init__(self, width=640, height=360, callback_thread_closed=None):\n\"\"\"Start the background camera thread if it isn't running yet.\"\"\"\n    BaseCamera.width = width\n    BaseCamera.height = height\n    BaseCamera.callback_thread_closed = callback_thread_closed\n    dummy_image = Image.open(DUMMY_IMAGE)\n    BaseCamera.dummy_image = np.asarray(dummy_image.resize((width, height)))\n</code></pre>"},{"location":"reference/motiontracker/camera/base_camera/#motiontracker.camera.base_camera.BaseCamera.frames","title":"<code>frames()</code>","text":"<p>\"Generator that returns frames from the camera.</p> Source code in <code>motiontracker\\camera\\base_camera.py</code> <pre><code>def frames():\n\"\"\"\"Generator that returns frames from the camera.\"\"\"\n    raise RuntimeError('Must be implemented by subclasses.')\n</code></pre>"},{"location":"reference/motiontracker/camera/base_camera/#motiontracker.camera.base_camera.BaseCamera.get_frame","title":"<code>get_frame(timeout=None)</code>","text":"<p>Return the current camera frame.</p> Source code in <code>motiontracker\\camera\\base_camera.py</code> <pre><code>def get_frame(self, timeout=None):\n\"\"\"Return the current camera frame.\"\"\"\n    BaseCamera.last_access = time.time()\n\n    # if the camera is off just return the dummy image\n    if BaseCamera.thread is None or BaseCamera.stop_flag:\n        log.debug(\"Sending Dummy Image\")\n        return self.dummy_image\n\n    # wait for a signal from the camera thread\n    log.debug(\"Inside Base Camera Get Frame, Waiting for Event\")\n    success = BaseCamera.event.wait(timeout=timeout)\n    if not success:\n        log.debug(\"Frame took to long, skipping frame and returning None\")\n        raise RuntimeError(\"No frame camera frame received\")\n    log.debug(\"Inside Base Camera Get Frame, Waiting to Clear Event\")\n    BaseCamera.event.clear()\n    return BaseCamera.frame\n</code></pre>"},{"location":"reference/motiontracker/camera/base_camera/#motiontracker.camera.base_camera.FrameEvent","title":"<code>FrameEvent()</code>","text":"<p>         Bases: <code>object</code></p> <p>An Event-like class that signals all active clients when a new frame is available.</p> Source code in <code>motiontracker\\camera\\base_camera.py</code> <pre><code>def __init__(self):\n    self.events = {}\n</code></pre>"},{"location":"reference/motiontracker/camera/base_camera/#motiontracker.camera.base_camera.FrameEvent.clear","title":"<code>clear()</code>","text":"<p>Invoked from each client's thread after a frame was processed.</p> Source code in <code>motiontracker\\camera\\base_camera.py</code> <pre><code>def clear(self):\n\"\"\"Invoked from each client's thread after a frame was processed.\"\"\"\n    self.events[get_ident()][0].clear()\n</code></pre>"},{"location":"reference/motiontracker/camera/base_camera/#motiontracker.camera.base_camera.FrameEvent.set","title":"<code>set()</code>","text":"<p>Invoked by the camera thread when a new frame is available.</p> Source code in <code>motiontracker\\camera\\base_camera.py</code> <pre><code>def set(self):\n\"\"\"Invoked by the camera thread when a new frame is available.\"\"\"\n    now = time.time()\n    remove = None\n    for ident, event in self.events.items():\n        if not event[0].isSet():\n            # if this client's event is not set, then set it\n            # also update the last set timestamp to now\n            event[0].set()\n            event[1] = now\n        else:\n            # if the client's event is already set, it means the client\n            # did not process a previous frame\n            # if the event stays set for more than 5 seconds, then assume\n            # the client is gone and remove it\n            if now - event[1] &gt; 5:\n                remove = ident\n    if remove:\n        del self.events[remove]\n</code></pre>"},{"location":"reference/motiontracker/camera/base_camera/#motiontracker.camera.base_camera.FrameEvent.wait","title":"<code>wait(timeout=None)</code>","text":"<p>Invoked from each client's thread to wait for the next frame.</p> Source code in <code>motiontracker\\camera\\base_camera.py</code> <pre><code>def wait(self, timeout=None):\n\"\"\"Invoked from each client's thread to wait for the next frame.\"\"\"\n    ident = get_ident()\n    if ident not in self.events:\n        # this is a new client\n        # add an entry for it in the self.events dict\n        # each entry has two elements, a threading.Event() and a timestamp\n        self.events[ident] = [threading.Event(), time.time()]\n    return self.events[ident][0].wait(timeout=timeout)\n</code></pre>"},{"location":"reference/motiontracker/camera/camera/","title":"camera","text":""},{"location":"reference/motiontracker/camera/camera/#motiontracker.camera.camera.Camera","title":"<code>Camera</code>","text":"<p>         Bases: <code>BaseCamera</code></p> <p>An emulated camera implementation that streams a repeated sequence of files 1.jpg, 2.jpg and 3.jpg at a rate of one frame per second.</p>"},{"location":"reference/motiontracker/camera/camera_opencv/","title":"camera_opencv","text":""},{"location":"reference/motiontracker/camera/camera_pi/","title":"camera_pi","text":""},{"location":"reference/motiontracker/camera/camera_video/","title":"camera_video","text":""},{"location":"reference/motiontracker/camera/camera_video/#motiontracker.camera.camera_video.Camera","title":"<code>Camera(video_fpath=None, states=None, callback_thread_closed=None)</code>","text":"<p>         Bases: <code>BaseCamera</code></p> Source code in <code>motiontracker\\camera\\camera_video.py</code> <pre><code>def __init__(self, video_fpath=None, states=None, callback_thread_closed=None ):\n    if os.environ.get('OPENCV_CAMERA_SOURCE'):\n        Camera.set_video_source(int(os.environ['OPENCV_CAMERA_SOURCE']))\n    else:\n        Camera.set_video_source(video_fpath)\n    super(Camera, self).__init__(callback_thread_closed=callback_thread_closed)\n    Camera.video_fpath = video_fpath\n    Camera.states = states\n</code></pre>"},{"location":"reference/motiontracker/utility/","title":"utility","text":""},{"location":"reference/motiontracker/utility/cv_util/","title":"cv_util","text":""},{"location":"reference/motiontracker/utility/cv_util/#motiontracker.utility.cv_util.findContours","title":"<code>findContours(imgPre, roi=[0, 0, 640, 360], min_area=1000, sort=True, filter=0, img=None, c=(255, 0, 0))</code>","text":"<p>Finds Contours in an image</p> <p>:param imgPre: Binary image on which we want to find contours. This image may be the result of a roi crop. :param roi: region of interest cropped from the original frame :param minArea: Minimum Area to detect as valid contour :param sort: True will sort the contours by area (biggest first) :param filter: Filters based on the corner points e.g. 4 = Rectangle or square, 0 = all accepted :param img: Image on which we want to draw contours :return: dictionary [contours, Area, BoundingBox, Center]</p> Source code in <code>motiontracker\\utility\\cv_util.py</code> <pre><code>def findContours(imgPre, roi = [0,0,640,360], min_area=1000, sort=True, filter=0, img=None, c=(255, 0, 0)):\n\"\"\"\n    Finds Contours in an image\n\n    :param imgPre: Binary image on which we want to find contours. This image may be the result of a roi crop.\n    :param roi: region of interest cropped from the original frame\n    :param minArea: Minimum Area to detect as valid contour\n    :param sort: True will sort the contours by area (biggest first)\n    :param filter: Filters based on the corner points e.g. 4 = Rectangle or square, 0 = all accepted\n    :param img: Image on which we want to draw contours\n    :return: dictionary [contours, Area, BoundingBox, Center]\n    \"\"\"\n\n    x_roi = roi[0]\n    y_roi = roi[1]\n\n    conFound = []\n    drawCon = img is not None\n    if drawCon:\n        img_contours = img.copy()\n    else:\n        img_contours = None\n    #roi = imgPre[y_roi:y_roi+h_roi, x_roi:x_roi+w_roi]\n    contours, hierarchy = cv2.findContours(imgPre, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n    for cnt in contours:\n        area = cv2.contourArea(cnt)\n        if area &gt; min_area:\n            peri = cv2.arcLength(cnt, True)\n            approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)\n            # print(len(approx))\n            if len(approx) == filter or filter == 0:\n                x, y, w, h = cv2.boundingRect(approx)\n                cx, cy = x + (w // 2), y + (h // 2)\n                conFound.append({\"cnt\": cnt, \"area\": area, \"bbox\": [x+x_roi, y+y_roi, w, h], \"center\": [cx+x_roi, cy+y_roi]})\n                if drawCon:\n                    # cv2.drawContours(img_contours, cnt, -1, c, 3)\n                    cv2.rectangle(img_contours, (x+x_roi, y+y_roi), (x+x_roi + w, y+y_roi + h), c, 1)\n                    cv2.rectangle(img_contours, (x_roi, y_roi), (x_roi + roi[2], y_roi + roi[3]), (0, 255, 0), 2)\n                    cv2.circle(img_contours, (x+x_roi + (w // 2), y+y_roi + (h // 2)), 1, c, 1)\n\n\n    if sort:\n        conFound = sorted(conFound, key=lambda x: x[\"area\"], reverse=True)\n    result = dict(contours=conFound, img_contours=img_contours)\n    return result\n</code></pre>"},{"location":"tutorials/materials-hardware/","title":"Materials, Construction, and Environment","text":"<p>Hardware Setup here</p>"},{"location":"tutorials/software-beginner/","title":"Tracking Software - First Steps","text":"<p>First steps tutorial here.</p>"},{"location":"tutorials/software-setup/","title":"Tracking Software - Setup and Installation","text":"<p>Software Setup tutorial here.</p>"}]}